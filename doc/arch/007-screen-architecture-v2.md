# ADR 007: Screen Architecture (v2)

## Status

Superceded by [008](./008-screen-architecture-v3.md) on 2019-10-01

## Context

Our [current screen architecture](001-screen-controllers.md) has a bunch of problems:

- We recreate application state from the UI state, which depends on some hidden behaviour:
  - RxBinding should have initial value observables that emit the current event immediately.
  - All widgets on the screen should save and restore state properly.
- The entire event stream is replayed because the system is setup in a way that they begin emission of events like ScreenCreated before the entire
  event handling loop is setup.
- The controller handles both, the business logic and the view logic.

All of these come together to make it hard to test and maintain screens. In addition, screens which perform a lot of business logic in memory require
a lot of working around the fact that the architecture depends on the state being saved either in persistence or by the platform mechanisms.

## Decision

### Goals

- Separate presentation and business logic so that they can tested independently of each other.
- Make UI state explicit and save/restore it manually instead of depending on hidden behaviour.
- Make it easy to migrate from the v1 architecture to the v2 for existing screens.

### Implementation

We split the controller into two discrete pieces, each with their own responsibility.

- `UiStateProducer`: This will be responsible for performing the function of the controller related to the business logic.
- `UiChangeProducer`: This will be responsible for performing the function of the controller related to the presentation logic.

In addition, we introduce a helper class, `ViewControllerBinding`, which is used to tie the state producer and consumer together with the event
stream.

#### Reference implementation

A reference implementation of the complete architecture can be found
at [this commit](https://github.com/simpledotorg/simple-android/blob/9e8412259e034e555fa40c2b07810a98d736df95/app/src/main/java/org/simple/clinic/shortcodesearchresult/ShortCodeSearchResultScreen.kt)
.

#### Terminology

- `Event`: a generated event. This will typically be events generated by the user interface, but might also include events generated by the platform
  like sensors, camera, etc. These will generally be represent as Kotlin data classes that implement the `UiEvent` interface.
- `UiState`: a Kotlin data class that represents everything needed to render the content of a given screen.
- `Ui`: an interface which represents all the functionality that the actual screen needs to provide to the controller.
- `UiChange`: a Kotlin lambda that has the signature `(Ui) -> Unit`.

#### Screen Setup Process

- Define a `UiState` for whatever view/screen is being built.
- Create a `UiStateProducer` which is an `ObservableTransformer<Event, UiState>`. This class will be responsible for business logic by transforming a
  stream of events into a stream of UI states.
- Create a `UiChangeProducer` which is an `ObservableTransformer<UiState, UiChange>`. This is responsible for presentation logic by transforming a
  stream of UI states into a stream of lambdas which will executed on the `Ui`.
- Create a controller which is an `ObservableTransformer<UiEvent, UiChange>` which will compose `UiStateProducer` and `UiChangeProducer` internally.
- Use the `ViewControllerBinding` to tie the event stream to the view.

##### Sample

```kotlin
@Inject
lateinit var uiStateProducer: ShortCodeSearchResultStateProducer

@Inject
lateinit var uiChangeProducer: ShortCodeSearchResultUiChangeProducer

lateinit var binding: ViewControllerBinding<UiEvent, ShortCodeSearchResultState, ShortCodeSearchResultUi>

override fun onFinishInflate() {
  // Inject the screen

  binding = ViewControllerBinding.bindToView(this, uiStateProducer, uiChangeProducer)

  newPatientButton.setOnClickListener { binding.onEvent(SearchPatient) }
}
```

### Goals Review

#### Separation of concerns and testability

Since the business logic and presentation logic are separated into two discrete components, testing them is simpler since they can be tested
independently of each other. In addition, we can test the behaviour of the business logic using value testing (asserting the generated states) which
is more readable than verifying behaviours using mocks.

#### UI state saving/restoration

Since the state of a screen is represented as a data class, saving and restoring the state is easy, and has just two steps:

1. Make the `UiState` class implement the `Parcelable` interface.
2. The `ViewControllerBinding` exposes two functions, `latestState()` and `restoreSavedState()`, which can be used in conjunction with the platform
   lifecycle methods.

#### Migrating from the older architecture

One of the major concerns about moving from the v1 architecture to v2 is breaking existing features while moving code around. Since both the v1 and v2
architectures expose the same overall interface (`ObservableTransformer<Event, UiChange>`), we can replace the controller in tests for the older
screens with a composition of the state producer and state consumer and verify that no behaviours were changed when migrating.

## Consequences

In legacy controllers, events were cached and replayed as soon as the screen was inflated without waiting for it to be attached to the view hierarchy.
In the v2 architecture, any events which are forwarded to the binding before the screen is attached to the view hierarchy, will be lost and ignored.
This is the correct way to implement the events, but some of the older screen controllers which were dependent on that behaviour might take more
effort to migrate to the current architecture.
